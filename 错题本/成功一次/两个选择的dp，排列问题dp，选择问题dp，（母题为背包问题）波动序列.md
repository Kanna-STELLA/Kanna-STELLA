==切入点== **两个选择的dp，排列问题dp，选择问题dp，（母题为背包问题）**
>[1214. 波动数列 - AcWing题库](https://www.acwing.com/problem/content/1216/)

// 1≤n≤1000
// ,
// −109≤s≤109
//  ,
// 1≤a,b≤106

// 范围在暗示用枚举类的方法，想dfs，dp

---

// 观察这个数列：

// 1 3 0 2 -1 1 -2 …

// 这个数列中后一项总是比前一项增加2或者减少3，且每一项都为整数。

// 栋栋对这种数列很好奇，他想知道长度为 n
//  和为 s
//  而且后一项总是比前一项增加 a
//  或者减少 b
//  的整数数列可能有多少种呢？

---

//  表达式
//  x + x + d1 + x + d1 + d2 + x + d1 + d2 + d3 + ...  = s;
//  s = n*x + (n-1)d1 + (n-2)d2 + (n-3)*d3 + ...;
//  x无限制，用有限制的量来表示
//  s - ((n-1)d1 + (n-2)d2 + (n-3)*d3 + ...)  / n = x;
//  因为x是整数，所以
//  s - ((n-1)d1 + (n-2)d2 + (n-3)*d3 + ...)一定是n的倍数
//  根据？同余定理，
//  s 同余 ((n-1)d1 + (n-2)d2 + (n-3)*d3 + ...) （mod n）

---
//  看((n-1)d1 + (n-2)d2 + (n-3)*d3 + ...)，要枚举每一个d选a还是b，可以开始dp分析，
//  两个选择的dp，排列问题dp，选择问题dp，（母题为背包问题）
 
>// 状态表示：      集合         用二维数组， f[i][j]，只考虑前i项，余数为j的情况数量 ==考虑ij范围==,
>
>>**i,1-n-1**
>>**j,0 ~n**
>>**j要模n**
>
>
>//                 属性    数量


>				
// 状态计算；      第i项选a还是b
//                 第i层的f[i][j]是由第i-1层选a+选b得到
//                 此时j = ((n-1)d1 + (n-2)d2 + (n-3)*d3 + ... + (n-i)di ) % n;
//                  
//                 多了一个(n-i)di，所以上一层的j就是这一层的j-(n-i)di，模n，同余定理，减法取模要补正
//                 如果上一层选了a，di >0,j-(n-i)di，  模n
//                 选了b，di < 0,j+(n-i)di，模n
//                 所以f[i][j] = f[i-1][选a] + f[i-1][选b]
// ，最后输出f[n][s % n];这是符合题意的情况汇总
>边界初始化 f[0][0] = 1;，因为数列的长度可以是1，即只有x一个元素，放到dp问题里就是空数列，考虑前0项，余数为0，即f[0][0] = 1;


// 检查范围
// 1≤n≤1000
// ,
// −109≤s≤109
//  ,
// 1≤a,b≤106
//mod 100000007
// 取模是1e8的，没有*10操作，不可能爆int
>==可能取到负数模，要手写取模函数==
```cpp

#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

int get_mod(int a,int b){
    return (a % b + b) % b;
}
// 卡壳，漏了题目关键流程要取模，由于是例题就没有按流程debug导致
const int N = 1e3 + 10,MOD =  100000007;
int f[N][N];
int main(){
    int n,s,a,b;
    cin >> n >> s >> a >> b;
    f[0][0] = 1;
    for(int i = 1;i <= n;i++){
        // 错误：i的范围应该是1到n-1，因为数组的第一项是任意的，且已经分离出去了，这里只有第二项开始往后的数
        for(int j = 0;j <= n;j++){ 
            // 卡壳，j的范围没有确定好，模n余数应该是0到n-1
            f[i][j] = (f[i-1][get_mod(j-(n-i)*a,n)] + f[i-1][get_mod(j + (n-i)*b,n)]) % MOD; 
            // 错误取模的数错误，这里数组保存的是题目结果，应该模 100000007，n是对于下标才要模的数
        }
    }
    cout << f[n-1][get_mod(s,n)];
    // 错误，同i范围没有确定的连带错误
    return 0;
}
                
                        
```

二刷一遍过
[云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/o5oavc3c)



三刷，漏了取模，wa1发，2发过
[云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/0d81yxs5)


四刷，一遍过
[云剪贴板 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/paste/x4lj1hws)